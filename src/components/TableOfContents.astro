<div id="table-of-contents-wrapper" class="hidden xl:block fixed top-1/2 -translate-y-1/2 right-[max(4rem,calc((100vw-1340px)/2-2rem))] w-[180px] opacity-0 transition-opacity duration-500 z-40">
  <div id="toc-list" class="overflow-y-auto group">
    <!-- 目录内容由 JavaScript 生成 -->
  </div>
</div>

<script is:inline>
  function initTableOfContents() {
    const articleContent = document.querySelector('.prose');
    if (!articleContent) {
      console.log('未找到 .prose 元素');
      return;
    }

    const tocContainer = document.getElementById('toc-list');
    if (!tocContainer) {
      console.log('未找到 #toc-list 元素');
      return;
    }

    // 提取所有标题（只提取 h2）
    const headingElements = articleContent.querySelectorAll('h2');

    if (headingElements.length === 0) {
      console.log('没有找到标题');
      return;
    }

    // 隐藏所有目录项文本，只显示当前正在阅读的章节
    const updateVisibleHeadings = () => {
      const tocLinks = document.querySelectorAll('#toc-list a');
      let currentActiveId = null;

      // 获取所有 h2 标题
      const headings = document.querySelectorAll('.prose h2');

      if (headings.length === 0) return;

      // 获取视口中间位置的绝对坐标
      const scrollY = window.pageYOffset;
      const viewportMiddleAbsolute = scrollY + window.innerHeight / 2;

      // 从前往后遍历所有 h2 标题，找到视口中间位置之后第一个标题
      // 那么当前阅读的章节就是这个标题的上一个章节
      for (let i = 0; i < headings.length; i++) {
        const heading = headings[i];
        const headingTop = heading.getBoundingClientRect().top + scrollY;

        // 如果找到第一个在视口中间之后的标题
        if (headingTop > viewportMiddleAbsolute) {
          // 当前章节是前一个 h2
          if (i > 0) {
            currentActiveId = headings[i - 1].id;
          } else {
            // 如果是第一个标题，且在视口中间之后，使用第一个标题
            currentActiveId = heading.id;
          }
          break;
        }

        // 如果这是最后一个标题，且在视口中间之前或重合，使用这个标题
        if (i === headings.length - 1) {
          currentActiveId = heading.id;
        }
      }

      // 检查是否正在 hover
      const isHovering = document.querySelector('#toc-list:hover') !== null;

      // 更新文本显示状态
      tocLinks.forEach((link) => {
        const headingId = link.dataset.headingId;
        if (!headingId) return;

        if (isHovering || headingId === currentActiveId) {
          link.style.visibility = 'visible';
          link.style.opacity = '1';
          link.classList.add('text-primary-light', 'dark:text-primary-dark', 'font-bold');
          link.classList.remove('text-text-light', 'dark:text-text-dark');
        } else {
          link.style.visibility = 'hidden';
          link.style.opacity = '0';
          link.classList.remove('text-primary-light', 'dark:text-primary-dark', 'font-bold');
          link.classList.add('text-text-light', 'dark:text-text-dark');
        }
      });
    };

    const headings = [];

    headingElements.forEach((heading) => {
      const text = heading.textContent || '';
      const id = heading.id || text.toLowerCase().replace(/[^a-z0-9\u4e00-\u9fa5]+/g, '-');

      if (!heading.id) {
        heading.id = id;
      }

      headings.push({
        id,
        text,
      });
    });

    console.log('找到的标题:', headings);

    // 渲染目录
    const createListItem = (item) => {
      const li = document.createElement('li');
      li.style.height = '20px';
      li.style.overflow = 'hidden';

      const wrapper = document.createElement('div');
      wrapper.className = 'flex items-center';

      const bar = document.createElement('span');
      bar.className = 'w-4 h-1 rounded-full bg-primary-light dark:bg-primary-dark mr-2 flex-shrink-0';

      const a = document.createElement('a');
      a.href = `#${item.id}`;
      a.textContent = item.text;
      a.className = 'block text-sm transition-colors duration-200 hover:text-primary-light dark:hover:text-primary-dark truncate text-text-light dark:text-text-dark font-medium';
      a.dataset.headingId = item.id;

      wrapper.appendChild(bar);
      wrapper.appendChild(a);
      li.appendChild(wrapper);

      return li;
    };

    const ul = document.createElement('ul');
    ul.className = 'space-y-2';
    headings.forEach((item) => {
      ul.appendChild(createListItem(item));
    });

    tocContainer.innerHTML = '';
    tocContainer.appendChild(ul);

    // 显示目录
    const tocWrapper = document.getElementById('table-of-contents-wrapper');
    if (tocWrapper) {
      tocWrapper.classList.remove('opacity-0');
      console.log('目录已显示');
    }

    // 初始化时更新可见标题
    updateVisibleHeadings();

    // 添加 hover 事件监听
    const tocList = document.getElementById('toc-list');
    if (tocList) {
      tocList.addEventListener('mouseenter', () => {
        updateVisibleHeadings();
      });
      tocList.addEventListener('mouseleave', () => {
        updateVisibleHeadings();
      });
    }

    // 添加滚动监听，动态更新可见标题
    let scrollTimeout;
    window.addEventListener('scroll', () => {
      clearTimeout(scrollTimeout);
      scrollTimeout = setTimeout(updateVisibleHeadings, 50);
    });

    // 添加平滑滚动
    document.querySelectorAll('#toc-list a').forEach((anchor) => {
      anchor.addEventListener('click', (e) => {
        e.preventDefault();
        const targetId = anchor.getAttribute('href')?.substring(1);
        if (!targetId) return;

        const targetElement = document.getElementById(targetId);
        if (targetElement) {
          const offset = 100; // 导航栏高度
          const targetPosition = targetElement.getBoundingClientRect().top + window.pageYOffset - offset;

          window.scrollTo({
            top: targetPosition,
            behavior: 'smooth',
          });
        }
      });
    });
  }

  // 页面加载时初始化
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      setTimeout(initTableOfContents, 100);
    });
  } else {
    setTimeout(initTableOfContents, 100);
  }

  // 监听 Astro 页面转换
  document.addEventListener('astro:after-swap', () => {
    setTimeout(initTableOfContents, 100);
  });
</script>
